package com.deniskharlamov.internship_cache;

public class Theory {

	/*
	 * Кэш или кеш (англ. cache) - промежуточный буфер с быстым доступом к нему, содержащий 
	 * информацию, которая может быть запрошена с наибольшей вероятностью. Доступ к данным в кэше 
	 * осуществляется быстрее, чем выборка исходных данных из более медленной памяти или удаленного 
	 * источника, однако ее объем существенно ограничен по сравнению с хранилищем исходных данных.
	 * 
	 * Буфер (англ. buffer - "посредник") - область памяти, используемая для временного хранения 
	 * данных при вводе или выводе.
	 * 
	 * Кэш состоит из набора записей. Каждая запись ассоциирована с элементом данных или блоком 
	 * данных (небольшой части данных), которая является копией элемента данных в основной памяти. 
	 * Каждая запись имеет идентификатор, часто называемый тегом, определяющий соответствие между 
	 * элементами данных в кэше и их копиями в основной памяти. 
	 * 
	 * Когда клиент кэша (ЦПУ, веб-браузер, операционная система) обращается к данным, прежде всего 
	 * исследуется кэш. Если в кэше найдена запись с идентификатором, совпадающим с идентификатором 
	 * затребованного элемента данных, то используются элементы данных в кэше. Такой случай 
	 * называется попаданием кэша. Если в кэше не найдена запись, содержащая затребованный элемент 
	 * данных, то он читается из основной памяти в кэш, и становится доступным для последующих 
	 * обращений. Такой случай называется промахом кэша. Процент обращений к кэшу, когда в нём 
	 * найден результат, называется уровнем попаданий, или коэффициентом попаданий в кэш. 
	 * 
	 * Наиболее эффективное правило вытеснения — отбрасывать из кэша ту информацию, которая не 
	 * понадобится в будущем дольше всего. Практический минимум может быть вычислен только опытным 
	 * путём, после чего можно равнить с ним эффективность текущего алгоритма кэширования (Алгоритм
	 * Белади).
	 * 
	 * 		Алгоритмы кэширования:
	 * 		----------------------
	 * 
	 * 		LRU (Least Recently Used) (Вытеснение давно неиспользуемых)
	 * 		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 * в первую очередь, вытесняется неиспользованный дольше всех. Этот алгоритм требует 
	 * отслеживания того, что и когда использовалось, что может оказаться довольно накладно, 
	 * особенно если нужно проводить дополнительную проверку, чтобы в этом убедиться. Общая 
	 * реализация этого метода требует сохранения «бита возраста» для строк кэша и за счет этого 
	 * происходит отслеживание наименее использованных строк (то есть за счет сравнения таких битов).
	 * 
	 * 		MRU (Most Recenly Used) (Наиболее недавно использующийся)
	 * 		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 * 		В отличие от LRU, в первую очередь вытесняется последний использованный элемент. 
	 * Алгоритмы MRU наиболее полезны в случаях, когда чем старше элемент, тем больше обращений к 
	 * нему происходит.
	 * 
	 * 		LFU (Least Frequently Used) (Наименее часто используемый)
	 * 		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 * 		подсчитывает как часто используется элемент. Те элементы, обращения к которым происходят
	 * реже всего, вытесняются в первую очередь.
	 * 
	 * 		ARC (Adaptive Replacement Cache) (Адаптивная замена)
	 * 		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 * 		Постоянно балансирует между LRU и LFU, что улучшает итоговый результат.
	 */
}














